From 16f4f7cdc4ca9253a5bf97ee0e2ce5afd666fbbb Mon Sep 17 00:00:00 2001
From: Kerberoge <sjoerdenjh@gmail.com>
Date: Sun, 25 Aug 2024 22:41:55 +0200
Subject: [PATCH 1/1] applied barcolors patch

---
 dwl.c | 89 +++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 83 insertions(+), 6 deletions(-)

diff --git a/dwl.c b/dwl.c
index ece537a..50d6ead 100644
--- a/dwl.c
+++ b/dwl.c
@@ -318,6 +318,7 @@ static void destroykeyboardgroup(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
+static int drawstatus(Monitor *m);
 static void focusclient(Client *c, int lift);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
@@ -448,7 +449,7 @@ static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
-static char stext[256];
+static char stext[512];
 static struct wl_event_source *status_event_source;
 
 static const struct wlr_buffer_impl buffer_impl = {
@@ -1519,11 +1520,8 @@ drawbar(Monitor *m)
 		return;
 
 	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
-		drwl_setscheme(m->drw, colors[SchemeNorm]);
-		tw = TEXTW(m, stext) - m->lrpad + 2; /* 2px right padding */
-		drwl_text(m->drw, m->b.width - tw, 0, tw, m->b.height, 0, stext, 0);
-	}
+	if (m == selmon) /* status is only drawn on selected monitor */
+		tw = drawstatus(m);
 
 	wl_list_for_each(c, &clients, link) {
 		if (c->mon != m)
@@ -1577,6 +1575,85 @@ drawbars(void)
 		drawbar(m);
 }
 
+int
+drawstatus(Monitor *m)
+{
+	int x, tw, iw;
+	char rstext[512] = "";
+	char *p, *argstart, *argend, *itext;
+	uint32_t scheme[3], *color;
+
+	/* calculate real width of stext */
+	for (p = stext; *p; p++) {
+		if (*p == '^') {
+			p++;
+			if (!strncmp(p, "fg(", 3) || !strncmp(p, "bg(", 3)) {
+				argend = strchr(p, ')');
+				if (!argend)
+					argend = p + 2;
+				p = argend;
+			} else if (*p == '^') {
+				strncat(rstext, p, 1);
+			} else {
+				strncat(rstext, p - 1, 2);
+			}
+		} else {
+			strncat(rstext, p, 1);
+		}
+	}
+	tw = TEXTW(m, rstext) - m->lrpad + 2; /* 2px right padding */
+
+	x = m->b.width - tw;
+	itext = stext;
+	scheme[0] = colors[SchemeNorm][0];
+	scheme[1] = colors[SchemeNorm][1];
+	drwl_setscheme(m->drw, scheme);
+	for (p = stext; *p; p++) {
+		if (*p == '^') {
+			p++;
+			if (!strncmp(p, "fg(", 3) || !strncmp(p, "bg(", 3)) {
+				*(p - 1) = '\0';
+				iw = TEXTW(m, itext) - m->lrpad;
+				if (*itext) /* only draw text if there is something to draw */
+					x = drwl_text(m->drw, x, 0, iw, m->b.height, 0, itext, 0);
+				*(p - 1) = '^';
+				
+				argstart = p + 3;
+				argend = strchr(argstart, ')');
+				if (!argend) argend = argstart - 1;
+				itext = argend + 1;
+
+				if (!strncmp(p, "fg(", 3)) /* foreground */
+					color = &scheme[0];
+				else /* background */
+					color = &scheme[1];
+
+				if (argend - argstart > 0) {
+					*argend = '\0';
+					*color = strtoul(argstart, NULL, 16);
+					*color = *color << 8 | 0xff; /* add alpha channel */
+					*argend = ')';
+				} else {
+					*color = 0;
+				}
+
+				/* reset color back to normal if none was provided */
+				if (!scheme[0])
+					scheme[0] = colors[SchemeNorm][0];
+				if (!scheme[1])
+					scheme[1] = colors[SchemeNorm][1];
+
+				drwl_setscheme(m->drw, scheme);
+				p = argend;
+			}
+		}
+	}
+	iw = TEXTW(m, itext) - m->lrpad;
+	if (*itext)
+		drwl_text(m->drw, x, 0, iw, m->b.height, 0, itext, 0);
+	return tw;
+}
+
 void
 focusclient(Client *c, int lift)
 {
-- 
2.46.0

